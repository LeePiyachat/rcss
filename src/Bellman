###############################################################################################
function Bellman(tnum::Int64,X::rcss,Index_be::Int64)
    if  -50 <= Index_be <= 0
        CondExpectation = ExpectedSlow
        println("Bellman with Slow method")
        if X.nnum[1]!= Index_be
            print("\n")
            print("Changing index to ", - Index_be, " neighbors \n" )
            X.nnum[:].=Index_be
        end
    elseif  0 < Index_be <= 50
        CondExpectation = ExpectedFast
        println("Bellman with Fast method")
        if X.nnum[1]!= Index_be
            print("\n")
            print("Recalculating matrix to ", Index_be, " neighbors \n" )
            X.nnum[:] .= Index_be
            X.Dmat[:,:,:] = Make_Dmat(X)
        end
    else error("No option for Bellman recursion")
    end
    #fields for value and expected value function
    Value = zero(Array{Float64}(undef,X.gnum,X.snum,X.pnum,tnum))
    Evalue= zero(Array{Float64}(undef,X.gnum,X.snum,X.pnum,tnum-1))
    #initialize backward induction

    t = tnum
    container = zero(Matrix{Float64}(undef, X.anum,X.snum))

    for p in 1: X.pnum
        for i in 1: X.gnum
            Value[i,:,p, t] = X.Scrap(t,X.grid[i,:],p, X.mp)
        end
    end

    t = tnum
    while (t > 1)
        t = t-1
        print(t)
        for p in 1: X.pnum
            #Evalue[:,:,p,t]= CondExpectation(value[:,:,p, t+1], X)
            Evalue[:,:,p,t]= CondExpectation(Value[:,:,p, t+1], X)
            print(".")
        end
        #
        for i in 1: X.gnum
            for p in 1:X.pnum
                container = zero(container)
                for a in 1:X.anum
                    for pp in 1:X.pnum
                        container[a,:] += X.control[p,pp,a] * Evalue[i,:,pp,t]
                    end
                    container[a,:]+= X.Reward(t,X.Grid[i,:], p, a, X.mp)
                end
                #amax = indmax(container * X.Grid[i,:])
                amax = argmax(container * X.Grid[i,:])
                Value[i,:,p,t] = container[amax,:]
            end
        end
    end
    return(Value, Evalue)
end
############################################################################
function Bellman(tnum::Int64,X::rcss,Index_be::Int64,scalar::String)
    if  -50 <= Index_be <= 0
        CondExpectation = ExpectedSlow
        println("Bellman with slow method")
        if X.nnum[1]!= Index_be
            print("\n")
            print("Changing index to ", -Index_be,"neighbors \n")
            X.nnum[:] .= Index_be
        end
    elseif  0 < Index_be <=50
        CondExpectation = ExpectedFast
        println("Bellman with fast method")
        if X.nnum[1] != Index_be
            print("\n")
            print("Recalculating matrix to ", Index_be, " neighbors \n")
            X.nnum[:] .= Index_be
            X.Dmat[:,:,:] = Make_Dmat(X)
        end
    else error("No such option for Bellman recursion")
    end
    #fields for value and expected value function
    Value   =   zero(Array{Float64}(undef, X.gnum,X.snum,X.pnum,tnum))
    Evalue  =   zero(Array{Float64}(undef, X.gnum,X.snum,X.pnum,tnum-1))
    #initialize backward induction
    t = tnum
    container   = zero(Array{Float64}(undef, X.pnum,X.anum))
    Evalues     = zero(Vector{Float64}(undef, X.pnum))
    #Evalue    = zero(Vector{Float64}(undef, X.pnum))
    #
    for p in 1: X.pnum
        for i in 1: X.gnum
            Value[i,:,p, t]= X.Scrap(t, X.Grid[i,:],p,X.mp)
        end
    end
    #
    t = tnum
    while (t > 1)
        t = t - 1
        print(t)
        for p in 1: X.pnum
            Evalue[:,:,p,t]= CondExpectation(Value[:,:,p, t+1],X)
            print(".")
        end
        #
        for i in 1: X.gnum
            for pp in 1:X.pnum
                Evalues[pp] = sum(Evalue[i,:,pp, t].* X.Grid[i,:])
                #Evalue[pp] = sum(Evalue[i,:,pp, t].* X.Grid[i,:])
            end
            for a in 1:X.anum
                container[:,a] = X.control[:,:,a] * Evalues
            end
            for p in 1:X.pnum
                for a in 1:X.anum
                    container[p,a] += X.Reward(t,X.Grid[i,:],p,a,X.mp,scalar)
                end
                amax = argmax(container[p,:])
                Value[i,:,p,t] = X.Reward(t,X.Grid[i,:], p,amax,X.mp)
                for pp in 1:X.pnum
                    Value[i,:,p,t]+= X.control[p,pp,amax] * Evalue[i,:,pp, t]
                end
            end
        end
    end
    return(Value,Evalue)
end
############################################################################
